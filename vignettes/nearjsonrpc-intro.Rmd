---
title: "nearjsonrpc: Introduction"
author: "Saw Simeon"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{nearjsonrpc: Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


# Introduction

nearjsonrpc provides small, focused wrappers around the NEAR Protocol JSON-RPC API. The goal is to
make it easy to query account state, blocks, network status, transactions and call view functions
from reproducible R scripts.

## Setup


```{r setup, include = FALSE}
# install.packages(c('httr2','jsonlite','tibble','dplyr','rlang','cli','pkgdown','testthat'))
# devtools::install()
# From GitHub
remotes::install_github("sawsimeon/nearjsonrpc")
library(nearjsonrpc)
# Or when on CRAN
# install.packages("nearjsonrpc")
```

Set the endpoint:

```{r endpoint, eval = TRUE}

near_set_endpoint('mainnet')

```

# Examples

## Query Acount Details and Balance

```{r account, eval = TRUE}
near_query_account("vitalik.near")
```

## List all access keys associated with a NEAR account

```{r keys, eval = TRUE}
keys = near_get_access_keys("vitalik.near")
keys
```

```{r all_info_keys, eval = TRUE}
library(dplyr)
library(purrr)
library(tidyr)
library(rlang)
keys = near_get_access_keys("vitalik.near")
library(dplyr)
library(purrr)
library(tidyr)
library(rlang)

# Flatten raw_response into a dataframe
all_keys_df <- map_dfr(keys$raw_response, function(resp) {
  # Some elements may not have $keys
  if (!is.null(resp$keys)) {
    map_dfr(resp$keys, function(k) {
      ak <- k$access_key
      pk <- k$public_key %||% NA_character_
      
      if (is.list(ak) && "FunctionCall" %in% names(ak$permission)) {
        fc <- ak$permission$FunctionCall
        tibble(
          block_hash   = resp$block_hash %||% NA_character_,
          block_height = resp$block_height %||% NA_integer_,
          public_key   = pk,
          nonce        = ak$nonce,
          allowance    = fc$allowance %||% NA_character_,
          method_names = if (length(fc$method_names) > 0) paste(fc$method_names, collapse = ", ") else NA_character_,
          receiver_id  = fc$receiver_id,
          permission_type = "FunctionCall"
        )
      } else {
        tibble(
          block_hash   = resp$block_hash %||% NA_character_,
          block_height = resp$block_height %||% NA_integer_,
          public_key   = pk,
          nonce        = ak$nonce,
          allowance    = NA_character_,
          method_names = NA_character_,
          receiver_id  = NA_character_,
          permission_type = "FullAccess"
        )
      }
    })
  } else {
    tibble(
      block_hash   = NA_character_,
      block_height = NA_integer_,
      public_key   = NA_character_,
      nonce        = NA_integer_,
      allowance    = NA_character_,
      method_names = NA_character_,
      receiver_id  = NA_character_,
      permission_type = NA_character_
    )
  }
})

all_keys_df

```

## Get Current Network Status and Node Info

```{r network, eval = TRUE}
status = near_network_status()
status
```

## Get NEAR Protocol Configuration

```{r protocol, eval = TRUE}
protocol_config = near_get_protocol_config()
protocol_config
```

## View NEAR Smart Contract

FT Metadata

```{r ft_metadata, eval = TRUE}
near_call_view_function("wrap.near", "ft_metadata")
```

Total supply

```{r ft_total_supply, eval = TRUE}
near_call_view_function("wrap.near", "ft_total_supply")
```

Balance query

```{r ft_balance_of, eval = TRUE}
near_call_view_function("wrap.near", "ft_balance_of",
                        args = list(account_id = "vitalik.near"))
```


# Data analysis 

## Top validators based on stakes

```{r plot, eval = TRUE}
library(ggplot2)
library(dplyr)
library(scales)

# Get recent validator stakes
vals <- near_get_validators()

vals %>%
  slice_head(n = 10) %>%
  ggplot(aes(x = reorder(account_id, stake_near), y = stake_near)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  scale_y_continuous(labels = comma) +   # makes stake readable with commas
  labs(
    title = "Top 10 Validators by Stake",
    x = "Validator",
    y = "Stake (NEAR)"
  ) +
  theme_minimal()

```

## Distribution of States (Major of the validators few Stakes)

```{r histogram, eval = TRUE}
vals %>%
  ggplot(aes(x = stake_near)) +
  geom_histogram(bins = 30, fill = "darkgreen", color = "white") +
  scale_x_continuous(labels = scales::comma) +
  labs(
    title = "Distribution of Validator Stakes",
    x = "Stake (NEAR)",
    y = "Number of Validators"
  ) +
  theme_minimal()
```

## Stake Share by Validator (Pie Chart)

```{r pie, eval = TRUE}
vals %>%
  slice_max(order_by = stake_near, n = 10) %>%
  ggplot(aes(x = "", y = stake_near, fill = account_id)) +
  geom_col(width = 1) +
  coord_polar(theta = "y") +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Top 10 Validators Stake Share",
    fill = "Validator"
  ) +
  theme_void()

```

## Concentration Index (Lorenz Curve)

Show how concentrated stake is among validators

```{r pie, eval = TRUE}
vals %>%
  arrange(desc(stake_near)) %>%
  mutate(cum_stake = cumsum(stake_near) / sum(stake_near),
         cum_validators = row_number() / n()) %>%
  ggplot(aes(x = cum_validators, y = cum_stake)) +
  geom_line(color = "gold", size = 1.2) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  labs(
    title = "Lorenz Curve of Validator Stakes",
    x = "Cumulative Share of Validators",
    y = "Cumulative Share of Stake"
  ) +
  theme_minimal()


```



# Error handling and best practices

- Avoid embedding real keys or signed transactions in vignettes or tests.

# Contributing

Please see the repository on GitHub. Open issues or PRs for improvements.
